<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LemonDB: LemonDB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LemonDB
   </div>
   <div id="projectbrief">A simple key-value database by Lemonion. Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">LemonDB </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>A simple multi-thread key-value database by Lemonion. Inc.</p>
<p>See more information in our official documentation <a href="https://tc-imba.github.io/VE482-p2/">HTML</a>/<a href="../latex/refman.pdf">PDF</a></p>
<h2>Compilation</h2>
<h3>Debug</h3>
<p>This version is used for debugging. </p><div class="fragment"><div class="line">mkdir debug &amp;&amp; cd debug</div><div class="line">cmake ..  -DCMAKE_BUILD_TYPE=Debug</div><div class="line">make lemondb</div><div class="line">src/lemondb</div></div><!-- fragment --><h3>Release</h3>
<p>This version is used for performance test. </p><div class="fragment"><div class="line">mkdir release &amp;&amp; cd release</div><div class="line">cmake ..  -DCMAKE_BUILD_TYPE=Release</div><div class="line">make lemondb</div><div class="line">src/lemondb</div></div><!-- fragment --><h2>Testing</h2>
<p>For a small test case, just use the files under <code>test</code> folder. Set the working directory as <code>test</code>, set the program argument as <code>test.query</code> or <code>test*.in</code>.</p>
<p>The test cases are too bug, so they are stored with Git LFS. See more information on <a href="https://git-lfs.github.com/">Git LFS pages</a>.</p>
<p>Once Git LFS extension is installed, you can download the test cases through cloning the submodule: </p><div class="fragment"><div class="line">git submodule init</div><div class="line">git submodule update</div></div><!-- fragment --><p>Set the working directory as <code>testcase/sample</code>, set the program argument as <code>*.query</code>, simply start debugging! (The loading query in all test files should be based on <code>testcase/sample</code> directory)</p>
<h2>Documentation</h2>
<p>The working flow of LemonDB is written by ourselves.</p>
<p>The class / function documentation is generated by <a href="http://www.doxygen.nl/">Doxygen</a>.</p>
<h3>Design</h3>
<ul>
<li>We design this program to make it can create 8 threads. We classify the queries using table and add them into queryqueue of corresponding table when we read them from the file. Once the table needed has been loaded completely, we will execute the queries as the order in queue and read query if the file hasn't ended at the same time.</li>
<li>Queries in the queryqueue will be run in the parallel.</li>
<li>Even in one query, for data queries that need searching and calculation such as SUB or SUM in a large table, we use a function addIterationTask to divide the table into several parts and search or calculate these parts simultaneously. Because the efficiency depends on the ratio between size of every part and size of the table, we did experiments and then find 10000 is a good size. For queries like TRUNCATE and INSERT, since they don't have to traverse the whole table, we don't add task for them.</li>
<li>The query class will use a "combine" function to check whether all the tasks dispatched by one query are all finished and organize them in the order and show on the screen.</li>
<li>When the user ask for quit, the quit query will check whether all tasks have already finished and and exit the program.</li>
</ul>
<h3>Performance Improvement</h3>
<p>We use many tricks to improve performance:</p><ul>
<li>Since we use a vector to store all data in a table, we obtain the advantage of efficient random access. Meanwhile, deleting and inserting datum becomes less efficient inevitably. However, we use some tricks to handle this issue. Notice that the vector is unordered, so for INSERT query it can be trivially appended to the vector with O(1). Then for DELETE and DUPLICATE query, we use a temporary vector <code>dataNew</code>. When iterating through data, those won't be deleted will be moved to dataNew by <code>std::move</code>, which is extremely fast. Then we simply swap <code>data</code> and <code>dataNew</code>, clear <code>dataNew</code> for further use. For DUPLICATE, things are slightly different. We insert duplicated data into <code>dataNew</code>, and then we append <code>dataNew</code> to <code>data</code>. These iteration can be executed in parallel, so <code>dataNew</code> is, of course, protected by a mutex.</li>
<li>Another great improvement is for those query with a condition 'KEY = someKey'. Making use of efficient random access, we keep a <code>keyMap</code> which stores index for given key. With this map, we can complete those query very efficiently, without iterating through data.</li>
<li>For those query without given key, we also improve the speed of evaluating condition. This is done by computing the condition explicitly for a specific query (by <code>std::function</code>), and simply pass this function to it. By doing so, we don't need to repeatedly compare string, convert string to integer, even switch among operators. This can save huge amount of time, because originally every datum use one general evaluating function. Now we just need to compute it once per query.</li>
<li>In some trivial cases atomic_int is used instead of having a mutex because it is much faster.</li>
</ul>
<h3>Problems Solved</h3>
<p>Due to our sophisticated design, we ran into many problems. These are some of them:</p><ul>
<li>We have encountered many problems about the query queue. The problem of LOAD query is the most difficult one, because it doesn't specify a table name. In our design, every table has a query queue so that we can decide the order to execute them, following reader/writer pattern. But LOAD doesn't have it, so it's very difficult to deicide where to put it, because the file may even not exist when the query is parsed and put into some queue. DUMP query is the reason we concern about this issue, so we solve it by keeping a map from filename to tablename. With this map, LOAD can decide whether the file is (or will be) created by DUMP or should exist already.</li>
<li>Another issue is COPYTABLE. This is the other query which can create a table, in which case it is responsible for starting the query queue to execute. And the problem is that COPYTABLE involves 2 table, so it should be pushed to both tables. And only when both query queues come to this query should it execute. This is done by keeping each other's pointer in it.</li>
<li>Other problems such as mutex or deadlock are less encountered, because we consider carefully about implementation before we start to code. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
